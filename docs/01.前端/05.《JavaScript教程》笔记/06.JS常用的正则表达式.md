---
title: JS常用的正则表达式
date: 2019-08-25 09:21:15
permalink: /pages/4aa87d/
categories: 
  - 前端
  - JS
tags: 
  - null
author: 
  name: kamalyes
  link: https://github.com/kamalyes
---
## 正则表达式
在表单验证中，使用正则表达式来验证正确与否是一个很频繁的操作，本文收集整理了15个常用的JavaScript正则表达式，其中包括用户名、密码强度、整数、数字、电子邮件地址（Email）、手机号码、身份证号、URL地址、 IPv4地址、 十六进制颜色、 日期、 QQ号码、 微信号、车牌号、中文正则。

### 用户名正则

    //用户名正则，4到16位（字母，数字，下划线，减号）
    var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
    //输出 true
    console.log(uPattern.test("hahaha"));

### 密码强度正则

    //密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
    var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
    //输出 true
    console.log("=="+pPattern.test("hahaHA123#"));

### 整数正则

    //正整数正则
    var posPattern = /^\d+$/;
    //负整数正则
    var negPattern = /^-\d+$/;
    //整数正则
    var intPattern = /^-?\d+$/;
    //输出 true
    console.log(posPattern.test("42"));
    //输出 true
    console.log(negPattern.test("-42"));
    //输出 true
    console.log(intPattern.test("-42"));

### 数字正则

    //正数正则
    var posPattern = /^\d*\.?\d+$/;
    //负数正则
    var negPattern = /^-\d*\.?\d+$/;
    //数字正则
    var numPattern = /^-?\d*\.?\d+$/;
    console.log(posPattern.test("42.2"));
    console.log(negPattern.test("-42.2"));
    console.log(numPattern.test("-42.2"));

### Email正则

    //Email正则
    var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
    //输出 true
    console.log(ePattern.test("1234567890@qq.com"));

### 手机号码正则

    //手机号正则
    var mPattern = /^1[34578]\d{9}$/; 
    //输出 true
    console.log(mPattern.test("15507621888"));

### 身份证号正则

    //身份证号（18位）正则
    var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
    //输出 true
    console.log(cP.test("11010519880605371X"));

### URL正则

    //URL正则
    var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
    //输出 true
    console.log(urlP.test("https://www.cnblogs.com/gujun1998/"));

### IPv4地址正则

    //ipv4地址正则
    var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    //输出 true
    console.log(ipP.test("192.168.0.1"));

### 十六进制颜色正则

    //RGB Hex颜色正则
    var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
    //输出 true
    console.log(cPattern.test("#b8b8b8"));

### 日期正则

    //日期正则，简单判定,未做月份及日期的判定
    var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
    //输出 true
    console.log(dP1.test("2017-05-11"));
    //输出 true
    console.log(dP1.test("2017-15-11"));
    //日期正则，复杂判定
    var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
    //输出 true
    console.log(dP2.test("2017-02-11"));
    //输出 false
    console.log(dP2.test("2017-15-11"));
    //输出 false
    console.log(dP2.test("2017-02-29"));

### QQ号正则

    //QQ号正则，5至11位
    var qqPattern = /^[1-9][0-9]{4,10}$/;
    //输出 true
    console.log(qqPattern.test("1234567890"));

### 微信号正则

    //微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
    var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
    //输出 true
    console.log(wxPattern.test("wohaha123_com"));

### 车牌号正则

    //车牌号正则
    var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
    //输出 true
    console.log(cPattern.test("粤S46006"));

### 包含中文正则

    //包含中文正则
    var cnPattern = /^[\u4E00-\u9FA5]$/;
    //输出 true
    console.log(cnPattern.test("大帅锅"));

参考链接：[http://caibaojian.com/form-regexp.html](http://caibaojian.com/form-regexp.html)

### 其他
```
匹配中文字符的正则表达式： [u4e00-u9fa5]

匹配双字节字符(包括汉字在内)：[^x00-xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）

匹配空白行的正则表达式：ns*r
评注：可以用来删除空白行

匹配HTML标记的正则表达式：< (S*?)[^>]*>.*?|< .*? />
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力

匹配首尾空白字符的正则表达式：^s*|s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式

匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
评注：表单验证时很实用

匹配网址URL的正则表达式：[a-zA-z]+://[^s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用

匹配国内电话号码：d{3}-d{8}|d{4}-d{7}
评注：匹配形式如 0511-4405222 或 021-87888822

匹配腾讯QQ号：[1-9][0-9]{4,}
评注：腾讯QQ号从10000开始

匹配中国邮政编码：[1-9]d{5}(?!d)
评注：中国邮政编码为6位数字

匹配身份证：d{15}|d{18}
评注：中国的身份证为15位或18位

匹配ip地址：d+.d+.d+.d+
评注：提取ip地址时有用

匹配特定数字：
^[1-9]d*$　 　 //匹配正整数
^-[1-9]d*$ 　 //匹配负整数
^-?[1-9]d*$　　 //匹配整数
^[1-9]d*|0$　 //匹配非负整数（正整数 + 0）
^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0）
^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数
^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数
^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数
^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
评注：处理大量数据时有用，具体应用时注意修正

匹配特定字符串：
^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串

在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下:
只能输入数字：“^[0-9]*$”
只能输入n位的数字：“^d{n}$”
只能输入至少n位数字：“^d{n,}$”
只能输入m-n位的数字：“^d{m,n}$”
只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$”
只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$”
只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$”
只能输入非零的正整数：“^+?[1-9][0-9]*$”
只能输入非零的负整数：“^-[1-9][0-9]*$”
只能输入长度为3的字符：“^.{3}$”
只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$”
只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$”
只能输入由26个小写英文字母组成的字符串：“^[a-z]+$”
只能输入由数字和26个英文字母组成的字符串：/^[A-Za-z0-9]+$/
只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$”
验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间

只能包含字符、数字和下划线。
验证是否含有^%&',;=?$"等字符：“[^%&',;=?$x22]+”
能输入汉字：“^[u4e00-u9fa5],{0,}$”

匹配中文字符的正则表达式： [u4e00-u9fa5]
匹配双字节字符(包括汉字在内)：[^x00-xff]
匹配空行的正则表达式：n[s| ]*r
匹配HTML标记的正则表达式：/< (.*)>.*|< (.*) />/
匹配首尾空格的正则表达式：(^s*)|(s*$)

验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12”
验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$”
```
<table class="reference notranslate">
<tbody><tr>
	<th width="20%">字符</th>
	<th width="80%">描述</th>
</tr>
<tr>
	<td>\</td>
    <td><p>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。</p></td>
</tr>
<tr>
	<td>^</td>
    <td><p>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。</p></td>
</tr>
<tr>
	<td>$</td>
    <td><p>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。</p></td>
</tr>
<tr>
	<td>*</td>
    <td><p>匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。</p></td>
</tr>
<tr>
	<td>+</td>
    <td><p>匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。</p></td>
</tr>
<tr>
	<td>?</td>
    <td><p>匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。</p></td>
</tr>
<tr>
	<td>{n}</td>
    <td><p>n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。</p></td>
</tr>
<tr>
	<td>{n,}</td>
    <td><p>n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。</p></td>
</tr>
<tr>
	<td>{n,m}</td>
    <td><p>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。</p></td>
</tr>
<tr>
	<td>?</td>
    <td><p>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。</p></td>
</tr>
<tr>
	<td>.</td>
    <td><p>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"<strong>(.|\n)</strong>"的模式。</p></td>
</tr>
<tr>
	<td>(pattern)</td>
    <td><p>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。</p></td>
</tr>
<tr>
	<td>(?:pattern)</td>
    <td><p>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。</p></td>
</tr>
<tr>
	<td>(?=pattern)</td>
    <td><p>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p></td>
</tr>
<tr>
	<td>(?!pattern)</td>
    <td><p>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p></td>
</tr>
<tr>
<td>(?&lt;=pattern)</td>
<td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"<code>(?&lt;=95|98|NT|2000)Windows</code>"能匹配"<code>2000Windows</code>"中的"<code>Windows</code>"，但不能匹配"<code>3.1Windows</code>"中的"<code>Windows</code>"。</td>
</tr>
<tr>
<td>(?&lt;!pattern)</td>
<td>反向否定预查，与正向否定预查类似，只是方向相反。例如"<code>(?&lt;!95|98|NT|2000)Windows</code>"能匹配"<code>3.1Windows</code>"中的"<code>Windows</code>"，但不能匹配"<code>2000Windows</code>"中的"<code>Windows</code>"。</td>
</tr>
<tr>
	<td>x|y</td>
    <td><p>匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。</p></td>
</tr>
<tr>
	<td>[xyz]</td>
    <td><p>字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。</p></td>
</tr>
<tr>
	<td>[^xyz]</td>
    <td><p>负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。</p></td>
</tr>
<tr>
	<td>[a-z]</td>
    <td><p>字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。</p></td>
</tr>
<tr>
	<td>[^a-z]</td>
    <td><p>负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。</p></td>
</tr>
<tr>
	<td>\b</td>
    <td><p>匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。</p></td>
</tr>
<tr>
	<td>\B</td>
    <td><p>匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。</p></td>
</tr>
<tr>
	<td>\cx</td>
    <td><p>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。</p></td>
</tr>
<tr>
	<td>\d</td>
    <td><p>匹配一个数字字符。等价于 [0-9]。</p></td>
</tr>
<tr>
	<td>\D</td>
    <td><p>匹配一个非数字字符。等价于 [^0-9]。</p></td>
</tr>
<tr>
	<td>\f</td>
    <td><p>匹配一个换页符。等价于 \x0c 和 \cL。</p></td>
</tr>
<tr>
	<td>\n</td>
    <td><p>匹配一个换行符。等价于 \x0a 和 \cJ。</p></td>
</tr>
<tr>
	<td>\r</td>
    <td><p>匹配一个回车符。等价于 \x0d 和 \cM。</p></td>
</tr>
<tr>
	<td>\s</td>
    <td><p>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p></td>
</tr>
<tr>
	<td>\S</td>
    <td><p>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p></td>
</tr>
<tr>
	<td>\t</td>
    <td><p>匹配一个制表符。等价于 \x09 和 \cI。</p></td>
</tr>
<tr>
	<td>\v</td>
    <td><p>匹配一个垂直制表符。等价于 \x0b 和 \cK。</p></td>
</tr>
<tr>
	<td>\w</td>
    <td><p>匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。</p></td>
</tr>
<tr>
	<td>\W</td>
    <td><p>匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。</p></td>
</tr>
<tr>
	<td>\xn</td>
    <td><p>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' &amp; "1"。正则表达式中可以使用 ASCII 编码。</p></td>
</tr>
<tr>
	<td>\num</td>
    <td><p>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。</p></td>
</tr>
<tr>
	<td>\n</td>
    <td><p>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</p></td>
</tr>
<tr>
	<td>\nm</td>
    <td><p>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</p></td>
</tr>
<tr>
	<td>\nml</td>
    <td><p>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</p></td>
</tr>
<tr>
	<td>\un</td>
    <td><p>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</p></td>
</tr>
</tbody></table>

表格来源：[菜鸟教程](https://www.runoob.com/regexp/regexp-metachar.html)
