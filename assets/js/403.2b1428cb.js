(window.webpackJsonp=window.webpackJsonp||[]).push([[403],{719:function(s,a,t){"use strict";t.r(a);var n=t(7),e=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"java-集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-集合"}},[s._v("#")]),s._v(" Java 集合")]),s._v(" "),a("h2",{attrs:{id:"分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[s._v("#")]),s._v(" 分类")]),s._v(" "),a("ul",[a("li",[s._v("普通集合")]),s._v(" "),a("li",[s._v("同步集合")]),s._v(" "),a("li",[s._v("并发集合")])]),s._v(" "),a("h2",{attrs:{id:"普通集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通集合"}},[s._v("#")]),s._v(" 普通集合")]),s._v(" "),a("h3",{attrs:{id:"connection-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#connection-接口"}},[s._v("#")]),s._v(" Connection 接口")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://www.yuyanqing.cn/oss/image-bed/col/backend/985104087d9f45bbbf231d503cea2096.png",alt:""}})]),s._v(" "),a("p",[a("strong",[s._v("List 有序,可重复")])]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ArrayList")]),s._v("\n优点"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 底层数据结构是数组，查询快，增删慢。\n缺点"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 线程不安全，效率高\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LinkedList")]),s._v("\n优点"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 底层数据结构是双向链表，查询慢，增删快。\n缺点"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 线程不安全，效率高\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector")]),s._v("\n优点"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 底层数据结构是数组，查询快，增删慢。\n缺点"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 线程安全，效率低\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[a("strong",[s._v("Set 无序,唯一")])]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashSet")]),s._v("\n底层数据结构是哈希表。"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("无序"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("唯一"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n如何来保证元素唯一性"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.")]),s._v("依赖两个方法："),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("和"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("equals")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LinkedHashSet")]),s._v("\n底层数据结构是链表和哈希表。"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("FIFO")]),s._v("插入有序"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("唯一"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.")]),s._v("由链表保证元素有序\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.")]),s._v("由哈希表保证元素唯一\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TreeSet")]),s._v("\n底层数据结构是红黑树。"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("唯一，有序"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h3",{attrs:{id:"map-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-接口"}},[s._v("#")]),s._v(" Map 接口")]),s._v(" "),a("p",[s._v("（key-value 的键值对，key 不允许重复，value 可重复，重复时会覆盖前一个 key）")]),s._v(" "),a("p",[a("strong",[s._v("Map 中的 key：无序的、不可重复的，value：无序的、可重复的")])]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashMap")]),s._v("：无序的，效率高，但不是线程安全的，key和value都允许为"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),s._v("。\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TreeMap")]),s._v("：有序的，底层使用红黑树，保证按照添加的key"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LinkedHashMap")]),s._v("：作为"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashMap")]),s._v("的子类，保证在遍历map元素时，可以按照添加的顺序实现遍历。因为它在原有的"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashMap")]),s._v("底层结构基础上，添加了一对指针，指向前一个和后一个。对于频繁的遍历操作，此类执行效率高于"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashMap")]),s._v("。\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashTable")]),s._v("：线程安全的，但是效率低，不允许"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),s._v("值。\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Map")]),s._v(" 集合即没有实现于 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Collection")]),s._v(" 接口，也没有实现 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Iterable")]),s._v(" 接口，所以不能对 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Map")]),s._v(" 集合进行 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("each 遍历。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://www.yuyanqing.cn/oss/image-bed/col/backend/4e8e6b5a7baf49edac64a4f9c587a1ff.png",alt:""}})]),s._v(" "),a("h2",{attrs:{id:"同步集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步集合"}},[s._v("#")]),s._v(" 同步集合")]),s._v(" "),a("p",[s._v("同步集合可以简单地理解为通过 synchronized 来实现同步的集合。如果有多个线程调用同步集合的方法，它们将会串行执行。")]),s._v(" "),a("ul",[a("li",[a("ol",[a("li",[s._v("Vector 是线程安全的，源码中有很多的 synchronized 可以看出，而 ArrayList 不是。导致 Vector 效率无法和 ArrayList 相比")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("ArrayList 和 Vector 都采用线性连续存储空间，当存储空间不足的时候，ArrayList 默认增加为原来的 50%，Vector 默认增加为原来的一倍")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[s._v("Vector 可以设置 capacityIncrement，而 ArrayList 不可以，从字面理解就是 capacity 容量，Increment 增加，容量增长的参数")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[s._v("Stack 是继承于 Vector，基于动态数组实现的一个线程安全的栈")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"5"}},[a("li",[s._v("arrayList、vector、Stack 的共性特点：随机访问速度快，插入和移除性能较差(这是数组的特点，三者的底层均为数组实现)")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"6"}},[a("li",[s._v("HashMap 是非 synchronized 的，而 Hashtable 是 synchronized 的。这说明 Hashtable 是线程安全的，而且多个线程可以共享一个 Hashtable")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"7"}},[a("li",[s._v("由于 Hashtable 是线程安全的，也是 synchronized 的，所以在单线程环境下比 HashMap 要慢")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"8"}},[a("li",[s._v("HashMap 可以存在 null 的键值(key)和值(value),但是 Hashtable 是不可以的")])])])]),s._v(" "),a("p",[a("strong",[s._v("同步集合在单线程的环境下能够保证线程安全，但是通过 synchronized 同步方法将访问操作串行化，导致并发环境下效率低下。而且同步集合在多线程环境下的复合操作（迭代、条件运算如没有则添加等）是非线程安全，需要客户端代码来实现加锁。")])]),s._v(" "),a("h2",{attrs:{id:"并发集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发集合"}},[s._v("#")]),s._v(" 并发集合")]),s._v(" "),a("p",[s._v("并发集合 是 jdk5.0 重要的特性，增加了并发包 java.util.concurrent.*。Java 内存模型、volatile 变量及 AbstractQueuedSynchronizer(简称 AQS 同步器)，是并发包众多实现的基础。")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v("常见的并发集合：\n\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ConcurrentHashMap")]),s._v("：线程安全的"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashMap")]),s._v("的实现\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("CopyOnWriteArrayList")]),s._v("：线程安全且在读操作时无锁的"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ArrayList")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("CopyOnWriteArraySet")]),s._v("：基于"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("CopyOnWriteArrayList")]),s._v("，不添加重复元素\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ArrayBlockingQueue")]),s._v("：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5.")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LinkedBlockingQueue")]),s._v("：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ArrayBlockingQueue")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])])])}),[],!1,null,null,null);a.default=e.exports}}]);